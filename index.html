<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buenas Prácticas de Código Limpio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados si son necesarios */
        body {
            font-family: "Inter", sans-serif;
            line-height: 1.6;
            background-color: #f4f7f6;
            color: #333;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #0056b3;
        }
        h3, h4 {
            color: #003b73;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #e9ecef;
        }
        .section-title {
            cursor: pointer;
            font-weight: bold;
            color: #003b73;
            transition: color 0.3s ease;
        }
         .section-title:hover {
            color: #0056b3;
        }
        .section-content {
            display: none; /* Ocultar contenido por defecto */
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }
        .section-content.visible {
            display: block;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        pre {
            background-color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        ul, ol {
            margin-left: 20px;
            margin-bottom: 10px;
        }
        li {
            margin-bottom: 5px;
        }
         footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-6 text-center">Buenas Prácticas de Código Limpio</h1>

        <p class="mb-8 text-center">Explora los principios fundamentales para escribir código de alta calidad, mantenible y legible, basados en las enseñanzas de Robert C. Martin.</p>

        <div class="section">
            <h2 class="section-title text-xl">1. Nombres Significativos</h2>
            <div class="section-content">
                <p>Elegir nombres claros y descriptivos para variables, funciones y clases es crucial. Los nombres deben revelar la intención del programador y evitar ambigüedades.</p>

                <h3 class="text-lg font-semibold mt-4">Revelar la intención</h3>
                <p>Un nombre debe responder por qué existe, qué hace y cómo se usa. Si necesita un comentario para explicarlo, el nombre no es lo suficientemente bueno.</p>
                <p><strong>Ejemplo (Malo):</strong></p>
                <pre><code>int d; // tiempo transcurrido en días</code></pre>
                <p><strong>Ejemplo (Bueno):</strong></p>
                <pre><code>int tiempoTranscurridoEnDias;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;</code></pre>
                <p>Considera este otro ejemplo, difícil de entender por la falta de nombres significativos:</p>
                <pre><code>public List&lt;int[]&gt; getThem() {
    List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();
    for (int[] x : theList)
        if (x[0] == 4)
            list1.add(x);
    return list1;
}</code></pre>
                 <p>Con nombres significativos y un poco de contexto (un juego de buscar minas):</p>
                 <pre><code>public List&lt;Cell&gt; getFlaggedCells() {
    List&lt;Cell&gt; flaggedCells = new ArrayList&lt;Cell&gt;();
    for (Cell cell : gameBoard)
        if (cell.isFlagged())
            flaggedCells.add(cell);
    return flaggedCells;
}</code></pre>

                <h3 class="text-lg font-semibold mt-4">Evitar la desinformación</h3>
                <p>No dejes pistas falsas. Evita palabras con significados que se alejen de tu intención o que puedan confundir.</p>
                <ul>
                    <li>No uses nombres específicos de plataformas si no aplican (ej. `hp`, `aix`).</li>
                    <li>No uses términos técnicos con un significado específico si no se ajustan (ej. `accountList` si no es una `List`).</li>
                    <li>Evita nombres con diferencias mínimas que puedan confundir (ej. `XYZControllerForEfficientHandlingOfStrings` vs. `XYZControllerForEfficientStorageOfStrings`).</li>
                    <li>Ten cuidado con caracteres que se parecen (ej. `l` minúscula o `O` mayúscula).</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Realizar distinciones con sentido</h3>
                <p>Los nombres deben tener significados distintos si son diferentes. No basta con añadir números o palabras redundantes.</p>
                <ul>
                    <li>Evita series numéricas (`a1`, `a2`).</li>
                    <li>Evita palabras adicionales sin sentido (`ProductInfo` vs. `Product`, `NameString` vs. `Name`).</li>
                    <li>Asegúrate de que las distinciones sean claras para el lector (ej. `getActiveAccount()`, `getActiveAccounts()`, `getActiveAccountInfo()` es confuso).</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Usar nombres que se puedan pronunciar y buscar</h3>
                <p>La programación es una actividad social. Debes poder hablar sobre tu código.</p>
                <ul>
                    <li>Usa nombres pronunciables (ej. `genymdhms` es malo, `generationTimestamp` es bueno).</li>
                    <li>Usa nombres que sean fáciles de buscar en el código. Evita nombres de una sola letra (excepto contadores de bucles en ámbitos muy pequeños) o constantes numéricas "mágicas".</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Evitar codificaciones</h3>
                <p>No codifiques información de tipo o ámbito en el nombre (ej. notación húngara, prefijos de miembro como `m_`). Los IDEs y los sistemas de tipos modernos hacen que esto sea innecesario y dificulta los cambios.</p>
                 <p><strong>Ejemplo (Malo con prefijo de miembro):</strong></p>
                <pre><code>public class Part {
    private String m_dsc; // La descripción textual
    void setName(String name) {
        m_dsc = name;
    }
}</code></pre>
                 <p><strong>Ejemplo (Bueno):</strong></p>
                 <pre><code>public class Part {
    String description;
    void setDescription(String description) {
        this.description = description;
    }
}</code></pre>
                <p>En el caso de interfaces e implementaciones, prefiere nombres sin adornos para las interfaces (ej. `ShapeFactory` en lugar de `IShapeFactory`).</p>

                <h3 class="text-lg font-semibold mt-4">Evitar asignaciones mentales</h3>
                <p>Los lectores no deben tener que traducir mentalmente tus nombres a lo que significan. La claridad es más importante que demostrar inteligencia.</p>

                <h3 class="text-lg font-semibold mt-4">Nombres de Clases y Métodos</h3>
                <ul>
                    <li><strong>Clases:</strong> Deben ser sustantivos o frases de sustantivo (ej. `Customer`, `WikiPage`, `Account`). Evita verbos o palabras como `Manager`, `Processor`, `Data`, `Info`.</li>
                    <li><strong>Métodos:</strong> Deben ser verbos o frases de verbo (ej. `postPayment`, `deletePage`, `save`). Usa convenciones estándar para accesores/mutadores (`get`, `set`, `is`).</li>
                    <li>Considera usar métodos de fábrica estáticos con nombres descriptivos para sobrecargar constructores.</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">No hacer juegos de palabras</h3>
                <p>Evita usar la misma palabra para dos conceptos diferentes, incluso si parece consistente (ej. un método `add` que suma números y otro que añade a una colección; usa `insert` o `append` para el segundo caso).</p>

                <h3 class="text-lg font-semibold mt-4">Usar nombres de dominios</h3>
                <ul>
                    <li><strong>Dominio de Soluciones:</strong> Usa términos técnicos de programación, algoritmos, patrones, etc., cuando sea apropiado (ej. `AccountVisitor`, `JobQueue`).</li>
                    <li><strong>Dominio de Problemas:</strong> Cuando no haya un término técnico, usa nombres del dominio del problema para que los expertos en el dominio puedan entenderlos.</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Añadir contexto con sentido</h3>
                <p>Incluye nombres en clases, funciones o espacios de nombres con nombres adecuados para darles contexto. Si es necesario, usa prefijos como último recurso, pero prefiere crear una clase para encapsular el concepto (ej. `addrFirstName` vs. una clase `Address`).</p>

                <h3 class="text-lg font-semibold mt-4">No añadir contextos innecesarios</h3>
                <p>No añadas prefijos redundantes a todas las clases de una aplicación (ej. `GSD` en todas las clases de Gas Station Deluxe). Esto dificulta el uso de herramientas y la legibilidad. Los nombres cortos y claros son mejores si el contexto ya es obvio.</p>

            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">2. Funciones</h2>
            <div class="section-content">
                <p>Las funciones deben ser pequeñas, hacer una sola cosa y hacerla bien. Deben tener pocos argumentos (idealmente cero, uno o dos) y evitar efectos secundarios inesperados.</p>

                <h3 class="text-lg font-semibold mt-4">Tamaño reducido</h3>
                <p>La primera regla es que deben ser pequeñas. La segunda es que deben ser aún más pequeñas. Idealmente, no más de 20 líneas, e incluso mejor, 2-4 líneas.</p>
                <p>La clave está en la abstracción. Cada línea de una función debe estar en el mismo nivel de abstracción que las demás. Si una línea está en un nivel más bajo, debe ser extraída a otra función.</p>

                <h3 class="text-lg font-semibold mt-4">Hacer una cosa</h3>
                <p>Una función debe hacer una sola cosa, hacerla bien y ser lo único que haga. Puedes saber si una función hace más de una cosa si puedes extraer otra función de ella con un nombre que no sea simplemente una reducción de su implementación.</p>
                <p>La regla del párrafo TO: Si puedes describir la función como un párrafo donde cada paso está un nivel de abstracción por debajo del nombre de la función, entonces probablemente hace una cosa.</p>

                <h3 class="text-lg font-semibold mt-4">Un nivel de abstracción por función</h3>
                <p>Todas las instrucciones dentro de una función deben estar en el mismo nivel de abstracción. No mezcles detalles de bajo nivel (ej. manipular cadenas de caracteres) con conceptos de alto nivel (ej. procesar una transacción).</p>
                <p>La regla descendente: El código debe leerse de arriba a abajo, con funciones de alto nivel llamando a funciones de bajo nivel definidas justo debajo. Esto crea un flujo narrativo fácil de seguir.</p>

                <h3 class="text-lg font-semibold mt-4">Instrucciones Switch</h3>
                <p>Las instrucciones switch son difíciles de mantener limpias y suelen hacer N cosas, violando el Principio de Responsabilidad Única (SRP) y el Principio Abierto/Cerrado (OCP). Si no se pueden evitar, deben estar encapsuladas en una fábrica abstracta y usarse para crear objetos polimórficos, ocultas detrás de una relación de herencia. Esto permite añadir nuevos casos sin modificar el código existente.</p>

                <h3 class="text-lg font-semibold mt-4">Argumentos de funciones</h3>
                <p>El número ideal de argumentos es cero (función monádica). Después uno (diádica), luego dos (triádica). Evita tres o más. Los argumentos aumentan la complejidad, dificultan la comprensión y hacen que las pruebas sean más difíciles.</p>
                <ul>
                    <li><strong>Argumentos de indicador (booleanos) son malos:</strong> Indican que la función hace más de una cosa (una para `true`, otra para `false`).</li>
                    <li><strong>Argumentos de salida son confusos:</strong> Es mejor que una función cambie el estado de su propio objeto contenedor en lugar de modificar un argumento pasado por referencia.</li>
                </ul>
                <p>Considera agrupar argumentos relacionados en un objeto con un nombre significativo para reducir el número de parámetros.</p>

                <h3 class="text-lg font-semibold mt-4">Sin efectos secundarios</h3>
                <p>Una función no debe hacer cosas ocultas además de lo que su nombre indica. Los efectos secundarios (modificar variables de instancia inesperadamente, modificar argumentos, modificar globales) causan confusión, dependencias temporales y hacen que el código sea impredecible.</p>

                <h3 class="text-lg font-semibold mt-4">Separación de consultas de comando</h3>
                <p>Una función debe ser un comando (hace algo, cambia el estado) o una consulta (responde algo, devuelve un valor), pero no ambas. Combinar ambas acciones en una función puede llevar a confusiones y errores lógicos (ej. `if (set("username", "unclebob"))`).</p>

                <h3 class="text-lg font-semibold mt-4">Mejor excepciones que devolver códigos de error</h3>
                <p>Devolver códigos de error mezcla la lógica de negocio con el manejo de errores y genera estructuras anidadas (`if/else` anidados). Usar excepciones separa el manejo de errores y simplifica el código, permitiendo que el flujo principal sea más legible.</p>

                <h3 class="text-lg font-semibold mt-4">Extraer bloques Try/Catch</h3>
                <p>Los bloques try/catch son feos y confunden la estructura del código. Extrae el cuerpo de los bloques try y catch en funciones separadas. El manejo de errores es una cosa, por lo que una función que maneja errores no debe hacer nada más que eso.</p>

                <h3 class="text-lg font-semibold mt-4">No repetirse (DRY - Don't Repeat Yourself)</h3>
                <p>Evita la duplicación de código. La duplicación es la raíz de muchos problemas (errores, inconsistencias, dificultad de mantenimiento). Si ves el mismo bloque de código más de una vez, extráelo a una función o clase.</p>

                <h3 class="text-lg font-semibold mt-4">Programación estructurada</h3>
                <p>Aunque las reglas de Dijkstra (una entrada, una salida por función/bloque) son valiosas, no son tan estrictas si las funciones son muy pequeñas. Evita el uso de `goto`.</p>

                <h3 class="text-lg font-semibold mt-4">Cómo crear este tipo de funciones</h3>
                <p>Las funciones limpias no se escriben de golpe. Se crean a través de un proceso iterativo de escritura, refactorización y limpieza, respaldado por pruebas unitarias. Escribe el código que funcione y luego límpialo.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">3. Comentarios</h2>
            <div class="section-content">
                <p>Los comentarios deben usarse con moderación. El código debe ser lo suficientemente claro como para no necesitar comentarios explicativos. Los buenos comentarios compensan nuestro fracaso al expresarnos en el código.</p>

                <h3 class="text-lg font-semibold mt-4">Los comentarios no compensan el código incorrecto</h3>
                <p>Si el código es confuso, no lo comentes; reescríbelo. El código claro con pocos comentarios es mejor que el código complicado con muchos comentarios. Un comentario es una excusa para código mal escrito.</p>

                <h3 class="text-lg font-semibold mt-4">Explicarse en el código</h3>
                <p>En muchos casos, puedes expresar lo que ibas a poner en un comentario creando una función con un nombre descriptivo o una variable con un nombre significativo.</p>
                 <p><strong>Ejemplo (Malo con comentario):</strong></p>
                 <pre><code>// Check to see if the employee is eligible for full benefits
if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))</code></pre>
                 <p><strong>Ejemplo (Bueno sin comentario):</strong></p>
                 <pre><code>if (employee.isEligibleForFullBenefits())</code></pre>

                <h3 class="text-lg font-semibold mt-4">Comentarios de calidad (Usos aceptables)</h3>
                <p>Hay algunos casos donde los comentarios son necesarios o beneficiosos:</p>
                <ul>
                    <li><strong>Comentarios legales:</strong> Derechos de autor, términos de licencia, etc.</li>
                    <li><strong>Comentarios informativos:</strong> Explicar el propósito de una expresión regular compleja, el formato de un archivo de datos, etc.</li>
                    <li><strong>Explicar la intención:</strong> Aclarar el por qué de una decisión de diseño particular o una solución no obvia a un problema.</li>
                    <li><strong>Clarificación:</strong> Traducir el significado de parámetros o valores de retorno de APIs externas confusas o legadas.</li>
                    <li><strong>Advertir de las consecuencias:</strong> Alertar a otros desarrolladores sobre algo importante (ej. una prueba que tarda mucho en ejecutarse, una limitación conocida, un posible problema de rendimiento).</li>
                    <li><strong>TODO:</strong> Marcar tareas pendientes (deben usarse con moderación y revisarse/eliminarse periódicamente).</li>
                    <li><strong>Amplificación:</strong> Resaltar la importancia de algo que podría pasarse por alto (ej. el uso de `trim()` en una cadena es crucial).</li>
                    <li><strong>Javadoc en API públicas:</strong> Documentar APIs destinadas a ser usadas por otros desarrolladores (aunque el código debe ser lo más autoexplicativo posible).</li>
                </ul>

                 <h3 class="text-lg font-semibold mt-4">Comentarios incorrectos (Evitar a toda costa)</h3>
                 <p>La mayoría de los comentarios caen en esta categoría. Mienten, confunden, ensucian el código y son un síntoma de código problemático.</p>
                 <ul>
                     <li><strong>Balbucear:</strong> Comentarios vagos, sin sentido o que el autor no se molestó en completar.</li>
                     <li><strong>Redundantes:</strong> Comentarios que simplemente repiten lo que el código ya dice. No añaden valor y deben eliminarse.</li>
                     <li><strong>Confusos:</strong> Comentarios que son incorrectos, engañosos o que contradicen el código.</li>
                     <li><strong>Obligatorios:</strong> Comentarios añadidos solo porque una regla lo exige (ensucian el código sin añadir información útil).</li>
                     <li><strong>Periódicos:</strong> Registros de cambios o historial de modificaciones en la parte superior del archivo (el sistema de control de versiones lo maneja de forma mucho más efectiva).</li>
                     <li><strong>Sobrantes:</strong> Comentarios obvios o triviales que no añaden valor (ej. comentar un constructor por defecto o una variable con un nombre claro).</li>
                     <li><strong>Sobrantes espeluznantes:</strong> Comentarios copiados y pegados incorrectamente de otro lugar.</li>
                     <li><strong>No usar comentarios si se puede usar una función o variable:</strong> Comentarios que explican algo que podría expresarse mejor en el código mediante refactorización.</li>
                     <li><strong>Marcadores de posición:</strong> Comentarios para marcar secciones (ej. `// Acciones //////////////////////////////////`). Generalmente innecesarios en código limpio con funciones pequeñas.</li>
                     <li><strong>Comentarios de llave de cierre:</strong> Comentarios que indican a qué bloque pertenece una llave de cierre (síntoma de funciones demasiado largas).</li>
                     <li><strong>Asignaciones y menciones:</strong> Comentarios que indican quién añadió qué o cuándo (el sistema de control de versiones lo maneja).</li>
                     <li><strong>Código comentado:</strong> ¡Nunca dejes código comentado en el sistema de control de versiones! Elimínalo; si lo necesitas, puedes recuperarlo del historial. El código comentado se acumula, miente y distrae.</li>
                     <li><strong>Comentarios HTML:</strong> El HTML dentro de los comentarios de código dificulta la lectura y el análisis.</li>
                     <li><strong>Información no local:</strong> Comentarios que dan información global del sistema en un contexto local (deben estar en un lugar más apropiado).</li>
                     <li><strong>Demasiada información:</strong> Comentarios con detalles irrelevantes, reflexiones históricas o información que no pertenece al código.</li>
                     <li><strong>Conexiones no evidentes:</strong> Comentarios cuya relación con el código que describen no es clara.</li>
                 </ul>
            </div>
        </div>

         <div class="section">
            <h2 class="section-title text-xl">4. Formato</h2>
            <div class="section-content">
                <p>El formato consistente y limpio es vital para la legibilidad. Esto incluye la indentación, el espaciado, la longitud de las líneas y la organización general del código.</p>

                <h3 class="text-lg font-semibold mt-4">La función del formato</h3>
                <p>El formato es crucial para la comunicación entre programadores. Un código bien formateado es más fácil de leer, entender y modificar, lo que mejora la productividad y reduce los errores.</p>

                <h3 class="text-lg font-semibold mt-4">Formato vertical</h3>
                <ul>
                    <li><strong>Tamaño de los archivos:</strong> Los archivos fuente deben ser pequeños. Los archivos de 200-500 líneas son manejables; miles de líneas son inaceptables.</li>
                    <li><strong>La metáfora del periódico:</strong> Organiza el código de arriba a abajo, con los conceptos de alto nivel (clases y funciones principales) al principio y los detalles de bajo nivel (funciones auxiliares, implementaciones) al final.</li>
                    <li><strong>Apertura vertical entre conceptos:</strong> Usa líneas en blanco para separar grupos de líneas que representan conceptos diferentes. Esto ayuda a escanear el código y ver las divisiones lógicas.</li>
                    <li><strong>Densidad vertical:</strong> Las líneas de código relacionadas directamente deben aparecer verticalmente densas (sin líneas en blanco entre ellas). Esto indica que están estrechamente relacionadas.</li>
                    <li><strong>Distancia vertical:</strong> Los conceptos relacionados deben mantenerse cerca. Las variables locales deben declararse lo más cerca posible de su uso. Las variables de instancia deben estar al principio de la clase. Las funciones que llaman a otras funciones deben estar verticalmente cerca, idealmente con la función invocada justo debajo de la que la invoca (regla descendente).</li>
                    <li><strong>Afinidad conceptual:</strong> Incluso si las funciones no se llaman directamente, si están relacionadas conceptualmente (ej. un conjunto de funciones que operan sobre la misma variable), deben estar verticalmente cerca.</li>
                    <li><strong>Orden vertical (regla descendente):</strong> Las funciones de alto nivel deben llamar a funciones de bajo nivel que se definen debajo de ellas. Esto crea un flujo narrativo natural cuando se lee el código.</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Formato horizontal</h3>
                <ul>
                    <li><strong>Ancho de línea:</strong> Mantén las líneas cortas, idealmente menos de 120 caracteres. Esto evita el desplazamiento horizontal y facilita la lectura en pantallas divididas o al imprimir.</li>
                    <li><strong>Apertura y densidad horizontal:</strong> Usa espacios horizontales para asociar elementos relacionados de cerca (ej. `a + b`) y separar elementos menos relacionados (ej. `int contador = 0;`). El espaciado puede usarse para reflejar la precedencia de operadores (ej. más espacio alrededor de operadores de menor precedencia).</li>
                    <li><strong>Alineación horizontal:</strong> Generalmente, evita alinear declaraciones o asignaciones horizontalmente. Aunque puede parecer ordenado inicialmente, es difícil de mantener y las herramientas de formato automático a menudo lo deshacen. Además, puede distraer del código real.</li>
                    <li><strong>Sangrado:</strong> Usa el sangrado para mostrar la jerarquía y el ámbito del código. Cada nivel de anidación (bloques `if`, `else`, `while`, `for`, cuerpo de función/clase) debe tener un nivel de sangrado adicional. Esto es crucial para la legibilidad. No rompas las reglas de sangrado para bloques cortos o funciones de una línea.</li>
                    <li><strong>Ámbitos ficticios:</strong> Si un cuerpo de bucle está vacío, sácalo a una línea separada y sángralo claramente para indicar que la intención es que esté vacío.</li>
                </ul>

                <h3 class="text-lg font-semibold mt-4">Reglas de equipo</h3>
                <p>Es crucial que un equipo de desarrollo acuerde un estilo de formato consistente y lo aplique rigurosamente. Usar herramientas de formato automático (linters, formatters) es la mejor manera de asegurar la consistencia.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">5. Objetos y Estructuras de Datos</h2>
            <div class="section-content">
                <p>Comprender la diferencia entre objetos (que ocultan sus datos y exponen funciones) y estructuras de datos (que exponen sus datos y no tienen funciones significativas) es importante para diseñar buen código.</p>

                <h3 class="text-lg font-semibold mt-4">Abstracción de datos</h3>
                <p>No expongas la implementación interna de tus datos. En lugar de variables públicas o getters/setters triviales (que exponen la implementación), expón abstracciones que permitan a los usuarios manipular la esencia de los datos sin conocer su representación interna. Esto protege tu código de los cambios en la estructura de datos subyacente.</p>
                <p><strong>Ejemplo (Exponiendo implementación):</strong></p>
                <pre><code>public class Point {
    public double x;
    public double y;
}</code></pre>
                 <p><strong>Ejemplo (Exponiendo abstracción):</strong></p>
                 <pre><code>public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}</code></pre>
                <p>La segunda versión oculta si el punto se almacena internamente en coordenadas cartesianas o polares.</p>

                <h3 class="text-lg font-semibold mt-4">Antisimetría de datos y objetos</h3>
                <p>Esta es la dicotomía fundamental entre el código procedural y el código orientado a objetos:</p>
                <ul>
                    <li><strong>Código Procedural (con Estructuras de Datos):</strong> Es fácil añadir nuevas funciones sin cambiar las estructuras de datos existentes. Es difícil añadir nuevos tipos de datos porque todas las funciones existentes tendrían que modificarse.</li>
                    <li><strong>Código Orientado a Objetos (con Objetos):</strong> Es fácil añadir nuevas clases (tipos de datos) sin cambiar las funciones existentes. Es difícil añadir nuevas funciones porque todas las clases existentes tendrían que modificarse.</li>
                </ul>
                <p>Elige el enfoque adecuado según si es más probable que necesites añadir nuevos tipos de datos o nuevos comportamientos (funciones).</p>

                <h3 class="text-lg font-semibold mt-4">La ley de Demeter</h3>
                <p>Una heurística importante: un módulo no debe conocer los detalles internos de los objetos que manipula. "No hables con desconocidos, solo con amigos".</p>
                <p>Para un objeto `C`, un método de `C` solo debe llamar a métodos de:</p>
                <ul>
                    <li>El propio `C`.</li>
                    <li>Los objetos creados por `C`.</li>
                    <li>Los objetos pasados como argumentos a los métodos de `C`.</li>
                    <li>Las variables de instancia de `C`.</li>
                </ul>
                <p>Evita "choques de trenes" (cadenas largas de llamadas a métodos como `objeto.getA().getB().getC()`). Esto expone la estructura interna de `A`, `B` y `C`.</p>
                <p>La aplicación de la ley depende de si los objetos son objetos (con comportamiento) o estructuras de datos (sin comportamiento). La ley se aplica más estrictamente a los objetos.</p>

                <h3 class="text-lg font-semibold mt-4">Híbridos</h3>
                <p>Evita las clases que son una mezcla de objeto y estructura de datos (tienen comportamiento y exponen datos públicos o accesibles por getters/setters triviales). Son lo peor de ambos mundos: dificultan añadir nuevas funciones y nuevos tipos de datos.</p>

                <h3 class="text-lg font-semibold mt-4">Ocultar la estructura</h3>
                <p>Interactúa con los objetos pidiéndoles que hagan cosas (llamando a sus métodos), en lugar de preguntarles por sus datos internos para que tú hagas algo con ellos. Esto mantiene la lógica de negocio fuera de las clases de datos y dentro de las clases que tienen comportamiento.</p>

                <h3 class="text-lg font-semibold mt-4">Objetos de transferencia de datos (OTD)</h3>
                <p>Son estructuras de datos puras (clases con variables públicas o bean-style con getters/setters triviales, sin comportamiento). Son útiles para comunicarse con bases de datos, analizar mensajes o representar estructuras simples. No les añadas lógica de negocio.</p>

                <h3 class="text-lg font-semibold mt-4">Registro activo (Active Record)</h3>
                <p>Una forma especial de OTD que también tiene métodos de navegación y persistencia (ej. métodos `save()`, `find()`). Aunque son convenientes, tienden a convertirse en híbridos. Trátalos principalmente como estructuras de datos y separa la lógica de negocio en objetos aparte.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">6. Manejo de Errores</h2>
            <div class="section-content">
                <p>Un buen código maneja los errores de forma limpia y elegante. Evita devolver códigos de error; en su lugar, usa excepciones. Proporciona contexto suficiente con las excepciones.</p>

                <h3 class="text-lg font-semibold mt-4">Usar excepciones en lugar de códigos devueltos</h3>
                <p>Devolver códigos de error (ej. `return -1;`) mezcla la lógica de negocio con el manejo de errores y hace que el código sea más difícil de leer y mantener, generando estructuras anidadas (`if/else` anidados). Usar excepciones separa el manejo de errores y permite que el flujo principal del código sea más legible y se centre en la lógica de negocio.</p>
                <p><strong>Ejemplo (Malo con código de error):</strong></p>
                <pre><code>public class AlgunasClase {
    public int funcionQuePuedeFallar() {
        // ... lógica ...
        if (error) {
            return -1; // Indica error
        }
        // ... lógica ...
        return 0; // Indica éxito
    }

    public void usarFuncion() {
        if (funcionQuePuedeFallar() == -1) {
            // Manejar error
        } else {
            // Continuar
        }
    }
}</code></pre>
                <p><strong>Ejemplo (Bueno con excepción):</strong></p>
                <pre><code>public class AlgunasClase {
    public void funcionQuePuedeFallar() throws MiExcepcion {
        // ... lógica ...
        if (error) {
            throw new MiExcepcion("Algo salió mal");
        }
        // ... lógica ...
    }

    public void usarFuncion() {
        try {
            funcionQuePuedeFallar();
            // Continuar si no hay excepción
        } catch (MiExcepcion e) {
            // Manejar error
        }
    }
}</code></pre>

                <h3 class="text-lg font-semibold mt-4">Crear primero la instrucción try-catch-finally</h3>
                <p>Define el ámbito de la transacción y el manejo de errores antes de escribir la lógica principal dentro del bloque `try`. Esto asegura que el código de manejo de errores esté presente y que el bloque `try` mantenga una naturaleza transaccional (si algo falla, se maneja). Esto ayuda a mantener el código de manejo de errores separado y limpio.</p>

                <h3 class="text-lg font-semibold mt-4">Usar excepciones sin comprobar (Unchecked Exceptions)</h3>
                <p>El libro argumenta que las excepciones comprobadas (checked exceptions) en Java pueden violar el principio abierto/cerrado y causar cascadas de cambios en la firma de los métodos. En muchas aplicaciones, los costos de dependencia superan las ventajas. Considera usar excepciones sin comprobar para errores de programación o envolver excepciones de terceros para unificar el manejo.</p>

                <h3 class="text-lg font-semibold mt-4">Ofrecer contexto junto a las excepciones</h3>
                <p>Las excepciones deben proporcionar suficiente contexto para diagnosticar el error. Incluye mensajes informativos que describan la operación fallida y el tipo de fallo. El rastreo de pila es útil, pero el mensaje de la excepción debe añadir contexto y ser comprensible.</p>

                <h3 class="text-lg font-semibold mt-4">Definir clases de excepción de acuerdo a las necesidades del invocador</h3>
                <p>Clasifica las excepciones según cómo se van a capturar y manejar en el código cliente, no según el origen del error. Envuelve APIs de terceros que lancen excepciones de bajo nivel con tus propias excepciones de más alto nivel para unificar el manejo y reducir las dependencias del código cliente en detalles de implementación externos.</p>

                <h3 class="text-lg font-semibold mt-4">Definir el flujo normal</h3>
                <p>Usa el Patrón de Caso Especial para evitar que el manejo de errores o casos excepcionales (que no son realmente errores, sino condiciones esperadas) interrumpa el flujo normal de la lógica de negocio. Crea objetos que representen el caso especial y que puedan ser tratados polimórficamente por el código cliente.</p>

                <h3 class="text-lg font-semibold mt-4">No devolver Null</h3>
                <p>Devolver `null` es una mala práctica que causa `NullPointerException` y requiere comprobaciones constantes en el código cliente. Esto ensucia el código y es fácil de olvidar. En su lugar, lanza una excepción o devuelve un objeto de caso especial (ej. una lista vacía en lugar de `null` cuando no se encuentran elementos).</p>

                <h3 class="text-lg font-semibold mt-4">No pasar Null</h3>
                <p>Pasar `null` como argumento es aún peor que devolverlo, ya que puede causar `NullPointerException` en cualquier parte del método invocado, a menudo lejos del punto donde se pasó el `null`. Evita pasar `null` siempre que sea posible. Usa aserciones o lanza excepciones de argumento inválido si es necesario, pero sobre todo, diseña tus métodos para que no acepten `null`.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">7. Pruebas Unitarias</h2>
            <div class="section-content">
                <p>Escribir pruebas unitarias limpias es tan importante como escribir código de producción limpio. Las pruebas deben ser legibles, rápidas, independientes, repetibles y automáticas (F.I.R.S.T.).</p>

                <h3 class="text-lg font-semibold mt-4">Las tres leyes del DGP (Desarrollo Guiado por Pruebas)</h3>
                <p>El Desarrollo Guiado por Pruebas (TDD) se basa en un ciclo rápido y simple:</p>
                <ol>
                    <li>No crear código de producción hasta tener una prueba unitaria que falle.</li>
                    <li>No crear más de una prueba unitaria que sea suficiente para fallar (y no compilar cuenta como fallo).</li>
                    <li>No crear más código de producción que el necesario para pasar la prueba que falla actualmente.</li>
                </ol>
                <p>Seguir estas leyes promueve un ciclo de desarrollo rápido, retroalimentación constante y asegura una alta cobertura de pruebas.</p>

                <h3 class="text-lg font-semibold mt-4">Realizar pruebas limpias</h3>
                <p>El código de prueba es tan importante como el código de producción. Debe ser limpio, legible y bien diseñado. Las pruebas sucias son difíciles de entender, mantener y terminan siendo abandonadas, lo que lleva a la degradación del código de producción.</p>

                <h3 class="text-lg font-semibold mt-4">Las pruebas propician posibilidades</h3>
                <p>Las pruebas unitarias bien escritas permiten que el código de producción sea flexible, mantenible y reutilizable porque reducen el miedo a realizar cambios. Con una buena suite de pruebas, puedes refactorizar, mejorar la arquitectura y añadir nuevas funcionalidades con confianza, sabiendo que las pruebas te alertarán si rompes algo.</p>

                <h3 class="text-lg font-semibold mt-4">Pruebas limpias: Legibilidad</h3>
                <p>La cualidad más importante de una prueba limpia es la legibilidad. Deben ser claras, simples y expresivas. Elimina los detalles irrelevantes y el código duplicado en las pruebas. La prueba debe contar una historia sobre el código que está probando.</p>
                <p>El patrón <strong>Generar-Operar-Comprobar (Arrange-Act-Assert)</strong> es una buena estructura para las pruebas: prepara los datos, ejecuta la acción que estás probando y verifica el resultado.</p>

                <h3 class="text-lg font-semibold mt-4">Lenguaje de pruebas específico del dominio</h3>
                <p>Crea funciones y utilidades auxiliares para construir una API de pruebas que facilite la escritura y lectura de las pruebas. Esto crea un lenguaje específico para el dominio de las pruebas, haciendo que las pruebas sean más expresivas y concisas.</p>

                <h3 class="text-lg font-semibold mt-4">Un estándar dual</h3>
                <p>El código de prueba puede tener estándares de eficiencia diferentes al código de producción (es aceptable que sea menos eficiente en CPU/memoria si eso mejora la legibilidad), pero nunca debe ser menos limpio en términos de estructura, legibilidad y diseño.</p>

                <h3 class="text-lg font-semibold mt-4">Una afirmación por prueba vs. Un solo concepto por prueba</h3>
                <p>Aunque la regla de una sola aserción por prueba puede promover la claridad, una guía más práctica es probar un solo concepto por función de prueba. Minimiza el número de aserciones por concepto que estás probando.</p>

                <h3 class="text-lg font-semibold mt-4">F.I.R.S.T.</h3>
                <p>Las pruebas unitarias limpias deben cumplir con estos cinco principios:</p>
                <ul>
                    <li><strong>Fast (Rápidas):</strong> Las pruebas deben ejecutarse rápidamente para que se ejecuten con frecuencia (idealmente, después de cada cambio pequeño).</li>
                    <li><strong>Independent (Independientes):</strong> Las pruebas no deben depender unas de otras. Cada prueba debe poder ejecutarse sola y en cualquier orden.</li>
                    <li><strong>Repeatable (Repetibles):</strong> Las pruebas deben poder ejecutarse en cualquier entorno (desarrollo, QA, producción) y producir el mismo resultado cada vez.</li>
                    <li><strong>Self-Validating (Validación automática):</strong> Las pruebas deben tener un resultado booleano claro (pasan o fallan) sin requerir evaluación manual o interpretación de registros.</li>
                    <li><strong>Timely (Puntuales):</strong> Las pruebas deben escribirse antes del código de producción que las hace pasar (TDD).</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">8. Clases</h2>
            <div class="section-content">
                <p>Las clases deben ser pequeñas y tener una única responsabilidad. Deben estar bien organizadas y ser cohesivas.</p>

                <h3 class="text-lg font-semibold mt-4">Organización de clases</h3>
                <p>Sigue una convención estándar para organizar el contenido de una clase (ej. en Java: constantes estáticas públicas, variables estáticas privadas, variables de instancia privadas, funciones públicas, utilidades privadas). Las funciones deben seguir la regla descendente, con las funciones de alto nivel al principio y las de bajo nivel al final.</p>

                <h3 class="text-lg font-semibold mt-4">Encapsulación</h3>
                <p>Mantén las variables de instancia y las funciones de utilidad privadas siempre que sea posible. La encapsulación protege los datos y la lógica interna de la clase. Relajar la encapsulación (ej. hacer variables públicas o usar getters/setters triviales) debe ser un último recurso y se considera un "código maloliente" (code smell).</p>

                <h3 class="text-lg font-semibold mt-4">Las clases deben ser de tamaño reducido</h3>
                <p>El tamaño de una clase se mide por sus responsabilidades, no por líneas de código. Una clase debe tener pocas variables de instancia y sus métodos deben usar la mayoría de ellas (alta cohesión).</p>

                <h3 class="text-lg font-semibold mt-4">El Principio de responsabilidad única (SRP)</h3>
                <p>Una clase debe tener uno y solo un motivo para cambiar. Este es el principio más importante para el diseño de clases. Identifica las responsabilidades (los motivos por los que la clase podría necesitar cambiar) y extrae las responsabilidades múltiples en clases separadas. Una clase con un nombre ambiguo (ej. `Manager`, `Processor`, `Super`) a menudo indica que tiene demasiadas responsabilidades.</p>
                <p>Un sistema con muchas clases pequeñas y cohesivas es más fácil de entender, mantener y probar que uno con pocas clases grandes y con muchas responsabilidades.</p>

                <h3 class="text-lg font-semibold mt-4">Cohesión</h3>
                <p>Las clases deben ser altamente cohesivas: los métodos y variables de la clase deben estar estrechamente relacionados y trabajar juntos como una unidad lógica. Una alta cohesión significa que los métodos de una clase usan la mayoría de sus variables de instancia.</p>
                <p>Si una clase tiene muchas variables de instancia que solo son utilizadas por un subconjunto de sus métodos, es una señal de baja cohesión y la clase probablemente debería dividirse en clases más pequeñas y cohesivas.</p>

                <h3 class="text-lg font-semibold mt-4">Mantener resultados consistentes en muchas clases de tamaño reducido</h3>
                <p>Dividir funciones grandes en funciones más pequeñas a menudo revela la necesidad de dividir clases grandes en clases más pequeñas y cohesivas. Este proceso de refactorización incremental, guiado por pruebas, mejora la estructura y la legibilidad del programa.</p>

                <h3 class="text-lg font-semibold mt-4">Organizar los cambios</h3>
                <p>Estructura tus clases de manera que los cambios en una parte del sistema tengan un impacto mínimo en otras partes. Las clases deben tener un solo motivo para cambiar (SRP).</p>

                <h3 class="text-lg font-semibold mt-4">Principio Abierto/Cerrado (OCP)</h3>
                <p>Las clases deben estar abiertas a la extensión pero cerradas a la modificación. Deberías poder añadir nuevas funcionalidades extendiendo las clases existentes (ej. mediante herencia o implementación de interfaces) en lugar de modificarlas directamente.</p>

                <h3 class="text-lg font-semibold mt-4">Aislarnos de los cambios</h3>
                <p>Usa interfaces y clases abstractas para aislar tus clases de los detalles de implementación concretos (ej. APIs de terceros, detalles de bases de datos). Esto cumple el Principio de Inversión de Dependencias (DIP) y facilita las pruebas, la reutilización y la flexibilidad del sistema.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">9. Sistemas</h2>
            <div class="section-content">
                <p>Los sistemas deben ser modulares y tener niveles de abstracción claros para gestionar la complejidad. La construcción de un sistema debe separarse de su uso.</p>

                <h3 class="text-lg font-semibold mt-4">Separar la construcción de un sistema de su uso</h3>
                <p>El proceso de inicio o configuración de un sistema (crear y conectar objetos, configurar dependencias) debe estar completamente separado de la lógica de ejecución que usa esos objetos para realizar el trabajo. Mezclar estas preocupaciones dificulta las pruebas, la modularidad y el cumplimiento de SRP.</p>

                <h3 class="text-lg font-semibold mt-4">Separar Main</h3>
                <p>Una forma de separar la construcción es poner toda la lógica de inicio y configuración en una función `main` o en módulos llamados por `main`. El resto del sistema (los objetos de negocio) asume que los objetos ya están construidos, configurados y listos para usar.</p>

                <h3 class="text-lg font-semibold mt-4">Factorías</h3>
                <p>Cuando la aplicación necesita crear objetos en tiempo de ejecución, pero los detalles de la construcción son complejos o dependen de la configuración, usa el patrón Fábrica Abstracta o Fábrica para mantener los detalles de la construcción separados de la lógica de negocio que usa los objetos creados.</p>

                <h3 class="text-lg font-semibold mt-4">Inyectar dependencias (DI)</h3>
                <p>La Inyección de Dependencias (DI) es un mecanismo poderoso para separar la construcción del uso. En lugar de que una clase cree sus propias dependencias, estas se le "inyectan" (a través de constructores, setters o interfaces), a menudo gestionado por un contenedor DI (framework como Spring, Guice, etc.). Esto invierte el control de la administración de dependencias y mejora la flexibilidad y la capacidad de prueba.</p>

                <h3 class="text-lg font-semibold mt-4">Evolucionar</h3>
                <p>Las arquitecturas de software pueden crecer y evolucionar incrementalmente si se mantienen los aspectos separados y se aplican los principios de código limpio. No necesitas un diseño perfecto desde el principio; puedes refactorizar y ampliar iterativamente a medida que comprendes mejor los requisitos y el dominio.</p>

                <h3 class="text-lg font-semibold mt-4">Aspectos transversales</h3>
                <p>Aspectos como la persistencia, la seguridad, el registro (logging) y las transacciones a menudo cruzan los límites de los objetos y módulos. La Programación Orientada a Aspectos (AOP) y mecanismos como los proxies pueden ayudar a modularizar estos aspectos, manteniéndolos separados de la lógica de negocio principal.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title text-xl">10. Código Maloliente (Code Smells)</h2>
            <div class="section-content">
                <p>El libro describe varios "olores" o síntomas de código que indican problemas subyacentes y sugieren la necesidad de refactorización. Identificar y eliminar estos "olores" es una parte crucial del proceso de limpieza del código.</p>

                <p>Los "code smells" no son errores funcionales, sino indicadores de que algo podría estar mal en el diseño o la estructura del código, lo que dificulta su comprensión, mantenimiento o extensión.</p>
                <h3 class="text-lg font-semibold mt-4">Algunos ejemplos comunes de Code Smells:</h3>
                <ul>
                    <li><strong>Comentarios inapropiados:</strong> Comentarios redundantes, engañosos, obligatorios, o que no se actualizan.</li>
                    <li><strong>Código comentado:</strong> Dejar código comentado en el sistema de control de versiones.</li>
                    <li><strong>Entornos de prueba incompletos:</strong> Falta de pruebas, pruebas que no cubren todos los casos importantes, o pruebas que son difíciles de ejecutar o mantener.</li>
                    <li><strong>Duplicación (Duplicated Code):</strong> El mismo bloque de código repetido en dos o más lugares. Es uno de los peores olores.</li>
                    <li><strong>Clases grandes (Large Class):</strong> Clases con demasiadas variables de instancia o métodos, indicando que tienen demasiadas responsabilidades.</li>
                    <li><strong>Listas de parámetros largas (Long Parameter List):</strong> Funciones o métodos con demasiados argumentos.</li>
                    <li><strong>Clases de datos (Data Class):</strong> Clases que solo tienen variables públicas (o getters/setters triviales) y no tienen comportamiento significativo.</li>
                    <li><strong>Dispersión envidiosa (Feature Envy):</strong> Un método que accede a los datos de otro objeto más de lo que accede a los suyos propios, sugiriendo que el método debería estar en la otra clase.</li>
                    <li><strong>Dependencias temporales (Temporal Coupling):</strong> Código donde el orden de las llamadas a métodos es crucial y no está claro o no está forzado por el sistema de tipos.</li>
                    <li><strong>Argumentos de indicador (Flag Arguments):</strong> Argumentos booleanos que controlan qué rama de un condicional se ejecuta dentro de una función.</li>
                    <li><strong>Nombres confusos (Obscured Intent):</strong> Nombres que no revelan la intención del programador.</li>
                    <li><strong>Funciones demasiado largas (Long Method):</strong> Funciones que hacen más de una cosa o que tienen demasiados niveles de anidación.</li>
                    <li><strong>Clases perezosas (Lazy Class):</strong> Una clase que no hace lo suficiente para justificar su existencia.</li>
                    <li><strong>Clases con acoplamiento excesivo (Shotgun Surgery):</strong> Un cambio requiere hacer muchos pequeños cambios en muchas clases diferentes.</li>
                    <li><strong>Intimidad indiscreta (Inappropriate Intimacy):</strong> Una clase que tiene dependencias excesivas o inapropiadas en los detalles internos de otra clase.</li>
                    <li><strong>Clases rechazadas (Refused Bequest):</strong> Una subclase que no utiliza la mayoría de los métodos o datos heredados de su superclase.</li>
                </ul>
                 <p>El libro proporciona una lista más exhaustiva y ejemplos de cómo refactorizar para eliminar estos olores, mejorando así la calidad del código.</p>
            </div>
        </div>

         <div class="section">
            <h2 class="section-title text-xl">11. Concurrencia</h2>
            <div class="section-content">
                <p>Escribir código concurrente limpio es un desafío significativo debido a los problemas de acceso compartido a datos, la complejidad de la sincronización y la dificultad de reproducir errores.</p>

                <p>El libro dedica un capítulo a las prácticas para escribir código concurrente que sea correcto, robusto y limpio. Los problemas de concurrencia son a menudo sutiles y difíciles de depurar.</p>
                <h3 class="text-lg font-semibold mt-4">Principios clave para la concurrencia limpia:</h3>
                <ul>
                    <li><strong>Principio de responsabilidad única (SRP):</strong> El código de concurrencia (semáforos, bloqueos, etc.) debe estar separado del resto de la lógica de negocio. No mezcles el código que resuelve el problema con el código que protege contra problemas de concurrencia.</li>
                    <li><strong>Limitar el acceso a datos compartidos:</strong> Reduce al mínimo el número de variables compartidas entre hilos. Cuantas menos variables compartidas haya, menos oportunidades habrá para problemas de concurrencia. Protege adecuadamente las variables compartidas (ej. con bloqueos).</li>
                    <li><strong>Usar copias de datos:</strong> Considera usar copias inmutables de datos o copias de datos que se pasan entre hilos en lugar de compartir el acceso a los datos originales. Esto puede simplificar la sincronización.</li>
                    <li><strong>Los hilos deben ser independientes:</strong> Diseña tus hilos para que sean lo más independientes posible. Evita que los hilos dependan del orden de ejecución o del tiempo de otros hilos.</li>
                    <li><strong>Conoce tu biblioteca concurrente:</strong> Familiarízate con las clases y herramientas de concurrencia estándar de tu lenguaje/plataforma (ej. `java.util.concurrent` en Java). Utiliza las abstracciones de alto nivel proporcionadas por la biblioteca en lugar de implementar tus propios mecanismos de sincronización de bajo nivel.</li>
                    <li><strong>Mantén tus secciones sincronizadas pequeñas:</strong> Reduce al mínimo el código dentro de los bloques sincronizados (bloqueos). Un código más pequeño dentro de los bloqueos reduce la probabilidad de interbloqueos (deadlocks) y mejora el rendimiento.</li>
                    <li><strong>Evita métodos sincronizados anidados:</strong> Ten mucho cuidado con los métodos sincronizados que llaman a otros métodos sincronizados, ya que pueden causar interbloqueos.</li>
                    <li><strong>Comprende los modelos de fallo:</strong> Los problemas de concurrencia pueden ser difíciles de reproducir porque dependen del tiempo y el orden de ejecución de los hilos. Prepárate para que los fallos sean esporádicos y difíciles de rastrear.</li>
                    <li><strong>Prueba el código concurrente:</strong> Las pruebas son cruciales para el código concurrente, pero deben diseñarse cuidadosamente para exponer problemas de concurrencia. Escribe pruebas que ejecuten el código concurrente repetidamente y en diferentes configuraciones para aumentar la probabilidad de encontrar errores.</li>
                </ul>
            </div>
        </div>

         <div class="section">
            <h2 class="section-title text-xl">12. Refactorización</h2>
            <div class="section-content">
                <p>La refactorización es el proceso de reestructurar el código existente sin cambiar su comportamiento externo, con el objetivo de mejorar su legibilidad, mantenibilidad y estructura. Es una disciplina clave en el desarrollo ágil.</p>

                <p>La refactorización no es una limpieza única, sino una actividad continua que se realiza como parte del desarrollo normal. Se hace para mejorar el diseño del código a medida que se desarrolla.</p>
                <h3 class="text-lg font-semibold mt-4">Principios de la refactorización:</h3>
                <ul>
                    <li><strong>Hazlo con frecuencia:</strong> La refactorización debe ser una parte regular del ciclo de desarrollo, no algo que se haga solo al final o en un sprint dedicado a la "limpieza".</li>
                    <li><strong>Hazlo en pequeños pasos:</strong> Realiza cambios pequeños y incrementales, ejecutando la suite de pruebas después de cada paso para asegurarte de que no has roto nada.</li>
                    <li><strong>Usa herramientas automatizadas:</strong> Aprovecha las herramientas de refactorización proporcionadas por tu IDE (ej. extraer método, renombrar variable, mover clase). Estas herramientas son confiables y reducen el riesgo de errores manuales.</li>
                    <li><strong>Ten una suite de pruebas robusta:</strong> Una suite de pruebas unitarias completa y rápida es tu red de seguridad durante la refactorización. Te permite hacer cambios con confianza, sabiendo que las pruebas te alertarán si alteras el comportamiento esperado.</li>
                    <li><strong>Refactoriza antes de añadir nueva funcionalidad:</strong> Limpia el código existente en el área donde vas a trabajar antes de añadir nuevas características. Esto facilita la integración del nuevo código.</li>
                    <li><strong>Refactoriza después de añadir nueva funcionalidad:</strong> Una vez que la nueva funcionalidad está funcionando y probada, refactoriza el código (tanto el nuevo como el existente) para mejorar su diseño.</li>
                </ul>
                <h3 class="text-lg font-semibold mt-4">Técnicas de refactorización comunes:</h3>
                <p>El libro y la literatura de refactorización describen muchas técnicas. Algunas comunes incluyen:</p>
                <ul>
                    <li>Extraer método/función (para reducir el tamaño de las funciones y mejorar la legibilidad).</li>
                    <li>Extraer clase (para dividir clases grandes con múltiples responsabilidades).</li>
                    <li>Renombrar variable/función/clase (para mejorar la claridad y la intención).</li>
                    <li>Sustituir número mágico por constante simbólica (para hacer el código más comprensible y fácil de modificar).</li>
                    <li>Mover método/campo (para mejorar la cohesión de las clases).</li>
                    <li>Reemplazar condicional con polimorfismo (para eliminar instrucciones `switch` o `if/else if` largas y facilitar la adición de nuevos tipos).</li>
                    <li>Encapsular campo (para ocultar la implementación interna de los datos).</li>
                    <li>Extraer interfaz (para cumplir el Principio de Inversión de Dependencias y facilitar las pruebas).</li>
                </ul>
                <p>La refactorización es una habilidad fundamental para mantener el código limpio y saludable a lo largo del tiempo.</p>
            </div>
        </div>

         <div class="section">
            <h2 class="section-title text-xl">13. Heurísticas y Patrones</h2>
            <div class="section-content">
                <p>El libro concluye con una lista de heurísticas (reglas generales, a menudo empíricas, derivadas de la experiencia) y patrones que ayudan a identificar y resolver problemas comunes de diseño y código. Estas son guías prácticas para escribir código limpio.</p>

                <p>Las heurísticas son reglas de pulgar que a menudo señalan un "código maloliente" o sugieren una mejor manera de hacer las cosas. Los patrones son soluciones probadas a problemas comunes de diseño.</p>
                 <h3 class="text-lg font-semibold mt-4">Ejemplos de heurísticas importantes:</h3>
                 <ul>
                     <li>Mantén las funciones pequeñas.</li>
                     <li>Mantén las clases pequeñas.</li>
                     <li>Una función debe hacer una cosa.</li>
                     <li>Sin argumentos de indicador.</li>
                     <li>Sin efectos secundarios.</li>
                     <li>Separación de comando y consulta.</li>
                     <li>Preferir excepciones a códigos de error.</li>
                     <li>No devolver null.</li>
                     <li>No pasar null.</li>
                     <li>Nombres descriptivos.</li>
                     <li>Evitar la duplicación (DRY).</li>
                     <li>SRP: La clase debe tener un solo motivo para cambiar.</li>
                     <li>OCP: Abierto para extensión, cerrado para modificación.</li>
                     <li>LSP: Principio de Sustitución de Liskov (los subtipos deben ser sustituibles por sus tipos base sin alterar la corrección del programa).</li>
                     <li>ISP: Principio de Segregación de Interfaces (las interfaces deben ser pequeñas y específicas del cliente, evitando interfaces "gordas").</li>
                     <li>DIP: Principio de Inversión de Dependencias (depender de abstracciones, no de concreciones; los módulos de alto nivel no deben depender de los módulos de bajo nivel).</li>
                     <li>Mantén los datos y el comportamiento juntos (cohesión).</li>
                     <li>Prefiere la composición a la herencia.</li>
                     <li>No confíes en los comentarios para explicar código malo.</li>
                     <li>Usa nombres que se puedan buscar.</li>
                     <li>No añadas contexto innecesario.</li>
                     <li>No añadas una cadena de contexto a los nombres.</li>
                     <li>Evita la dispersión envidiosa.</li>
                     <li>Evita los límites artificiales (clases/paquetes sin sentido).</li>
                     <li>Las clases base no deben conocer a sus derivadas.</li>
                     <li>Prefiere los objetos de datos activos a los registros activos como objetos de negocio.</li>
                     <li>Evita las estructuras de datos que contengan solo un tipo de datos primitivo.</li>
                     <li>Evita las clases con demasiadas variables de instancia.</li>
                     <li>Evita los métodos con demasiados argumentos.</li>
                     <li>Evita los métodos con demasiados niveles de anidación.</li>
                     <li>Evita los métodos que hacen más de una cosa.</li>
                     <li>Evita la duplicación en las pruebas.</li>
                     <li>Las pruebas deben ser F.I.R.S.T.</li>
                 </ul>
                 <h3 class="text-lg font-semibold mt-4">Patrones de diseño mencionados (entre otros):</h3>
                 <p>El libro hace referencia a varios patrones de diseño que ayudan a estructurar el código de manera limpia:</p>
                 <ul>
                     <li>Fábrica Abstracta (Abstract Factory)</li>
                     <li>Estrategia (Strategy)</li>
                     <li>Plantilla de Método (Template Method)</li>
                     <li>Patrón de Caso Especial (Special Case Pattern)</li>
                     <li>Inyección de Dependencias (Dependency Injection)</li>
                     <li>Proxy</li>
                     <li>Adaptador (Adapter)</li>
                     <li>Decorador (Decorator)</li>
                 </ul>
                 <p>Estas heurísticas y patrones son herramientas valiosas para identificar problemas y aplicar soluciones probadas al escribir y refactorizar código.</p>
            </div>
        </div>

        <footer>
            <p>&copy; victorcabas</p>
        </footer>


    </div>

    <script>
        // JavaScript para la interactividad y el scroll
        document.addEventListener('DOMContentLoaded', () => {
            const sectionTitles = document.querySelectorAll('.section-title');

            sectionTitles.forEach(title => {
                title.addEventListener('click', () => {
                    const section = title.parentElement; // Obtiene el elemento padre .section
                    const content = title.nextElementSibling;

                    // Ocultar todos los demás contenidos antes de mostrar el actual
                    document.querySelectorAll('.section-content').forEach(otherContent => {
                        if (otherContent !== content) {
                            otherContent.classList.remove('visible');
                            // Resetear el botón "Mostrar más" de otras secciones
                            const otherMoreInfo = otherContent.querySelector('.more-info');
                            if (otherMoreInfo && !otherMoreInfo.classList.contains('hidden')) {
                                otherMoreInfo.classList.add('hidden');
                                const otherButton = otherMoreInfo.previousElementSibling;
                                if (otherButton && otherButton.tagName === 'BUTTON') {
                                    otherButton.textContent = 'Mostrar más';
                                }
                            }
                        }
                    });

                    // Alternar la clase 'visible' en el contenido clicado
                    const isVisible = content.classList.toggle('visible');

                    // Si la sección se acaba de abrir, desplazar hacia ella
                    if (isVisible) {
                        section.scrollIntoView({
                            behavior: 'smooth', // Desplazamiento suave
                            block: 'start' // Alinea la parte superior del elemento con la parte superior del viewport
                        });
                    } else {
                         // Resetear el botón "Mostrar más" si se colapsa la sección
                         const currentMoreInfo = content.querySelector('.more-info');
                         if (currentMoreInfo && !currentMoreInfo.classList.contains('hidden')) {
                             currentMoreInfo.classList.add('hidden');
                             const currentButton = currentMoreInfo.previousElementSibling;
                             if (currentButton && currentButton.tagName === 'BUTTON') {
                                 currentButton.textContent = 'Mostrar más';
                             }
                         }
                    }
                });
            });
        });

        function mostrarMas(button) {
            const moreInfo = button.nextElementSibling;
            moreInfo.classList.toggle('hidden');
            button.textContent = moreInfo.classList.contains('hidden') ? 'Mostrar más' : 'Mostrar menos';
        }
    </script>
</body>
</html>
